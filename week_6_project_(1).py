# -*- coding: utf-8 -*-
"""Week_6_project (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jIkNmNiXVrqBlBIF40uy8sBiRjkbn29_

Data set is from https://www.kaggle.com/datasets/cpluzshrijayan/milkquality/data, titled "Milk Quality Prediction"
"""

#Read in csv
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from scipy.io import loadmat
from sklearn import preprocessing



from google.colab import files

uploaded=files.upload()

milk = pd.read_csv('milknew.csv')
milk.head()

"""Correlation"""

correlation= milk.corr()
correlation

milk['Grade'].unique()

labels = preprocessing.LabelEncoder()
milk['Grade'] = labels.fit_transform(milk['Grade'])
milk['Grade'].unique()

X =milk.drop(['Grade'], axis=1)
y= milk['Grade']

#Standardize the data
from sklearn.preprocessing import StandardScaler
PredScale= StandardScaler()
PredScaleFit= PredScale.fit(X)
X=PredScaleFit.transform(X)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np



#Split into train and test

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.25,random_state=50)

"""Gaussian Naive Bayes"""

from keras.metrics import Accuracy
from keras.src.metrics.regression_metrics import R2Score
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn import metrics
from sklearn.naive_bayes import GaussianNB
gnb = GaussianNB()
gnb.fit(X_train, y_train)
y_pred= np.argmax(model.predict(X_test), axis=-1)
print('Accuracy:', metrics.accuracy_score(y_pred,y_test))
print (confusion_matrix (y_pred,y_test))
print(classification_report (y_pred,y_test))

"""Logistic Regression"""

from keras.models import Sequential
from keras.layers import Dense
from keras.regularizers import l2, l1
from keras.optimizers import SGD
from keras import metrics

#Scale data
scale= StandardScaler()
scale.fit(X_train)

X_train_scale= scale.transform(X_train)
X_test_scale= scale.transform(X_test)

model= Sequential()

model.add(Dense(units=1, input_shape=[X_train.shape[1]],activation='sigmoid', kernel_regularizer=l2(0.01)))

sgd = SGD(learning_rate=0.1)
model.compile(loss='binary_crossentropy', optimizer=sgd, metrics= ['accuracy'])

model.summary()

history = model.fit(X_train_scale, y_train, batch_size = 50,
          epochs = 100, verbose=0, validation_data=(X_test_scale,y_test))

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(6,4))
# # summarize history for loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'], 'g--')
plt.title('Logistic Regression Model Loss')
plt.ylabel('Binary Crossentropy')
plt.xlabel('Epoch')
plt.legend(['Training Loss', 'Testing Loss'], loc='upper right')
print("Loss after final iteration: ", history.history['val_loss'][-1])
print("Accuracy:", history.history['accuracy'][-1])
plt.show()

"""Neural Network"""

from keras.models import Sequential
from keras.layers import Dense
from keras.regularizers import l2, l1
from keras import optimizers
from sklearn import metrics
from keras import metrics
from tensorflow.keras.layers import BatchNormalization

y_train = np.asarray(y_train).astype('float32').reshape((-1,1))
y_test = np.asarray(y_test).astype('float32').reshape((-1,1))

model=Sequential()

model.add(Dense(75,activation='relu'))
model.add(BatchNormalization())

model.add(Dense(32,activation='relu'))
model.add(BatchNormalization())

model.add(Dense(15,activation='relu'))
model.add(BatchNormalization())

model.add(Dense(1,activation='sigmoid'))

sgd= SGD(learning_rate=0.01)

model.compile(optimizer = 'adam', loss ='binary_crossentropy', metrics=['accuracy'])

history = model.fit(X_train, y_train, batch_size = 25, epochs = 100, validation_data=(X_test,y_test))

from sklearn import metrics
print('Accuracy:', metrics.accuracy_score(y_pred,y_test))
print (confusion_matrix (y_pred,y_test))
print(classification_report (y_pred,y_test))

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(6,4))
# # summarize history for loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'], 'g--')
plt.title('Neural Network Model Loss')
plt.ylabel('Binary Crossentropy')
plt.xlabel('Epoch')
plt.legend(['Training Loss', 'Testing Loss'], loc='upper right')
print("Loss after final iteration: ", history.history['val_loss'][-1])
print("Accuracy:", history.history['accuracy'][-1])
plt.show()

"""Support Vector Machiene"""

from sklearn.metrics import accuracy_score
from sklearn.svm import SVC
svm = SVC(kernel='linear', random_state=0)
svm.fit(X_train, y_train)
y_pred= svm.predict(X_test)
accuracy= accuracy_score(y_test, y_pred)
print(accuracy)
print (confusion_matrix (y_test, y_pred))
print(classification_report(y_test, y_pred))

"""Decision Tree"""

from sklearn.tree import DecisionTreeClassifier
from sklearn import metrics
import matplotlib.pyplot as plt
tree= DecisionTreeClassifier(random_state=30)
tree.fit(X_train, y_train)
y_pred= tree.predict(X_test)
accuracy= metrics.accuracy_score(y_test, y_pred)
print(accuracy)
print (confusion_matrix (y_test, y_pred))
print(classification_report(y_test, y_pred))